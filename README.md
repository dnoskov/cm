# cm

лабы по численным методам. делаю на scala. ничего интересного здесь нет, смело проходите мимо

# Инструктион

1. Прочитать какой-нибудь вариант из файлов с вариантами при помощи:
   `common.input.Octave.readOctaveSave(filename: String)`

   `filename` - имя одного из файлов из директории `octave/lab02` (например,
   для второй лабы)

   метод вернёт пару `(Array[Array[Double], Array[Double])`, состоящую из матрицы левой части
   и вектора правой части.

2. эти штуки надо передать соответствующему классу из пакета
   `lab0x.<название_метода>`. Соответственно, смотрите контракт этих методов
   на предмет дополнительных аргументов.

   например, `lab02.Jacobi` - это первый итерационный метод: Якоби, имеет
   следующий конструктор:
   
```scala
case class Jacobi(L: Array[Array[Double]], r: Array[Double],
     eps: Double,
     x0: Array[Double]) extends Method(L,r)
```

В результате выполнения конструктора выполнятся необходимые вычисления,
и результат тогда можно будет посмотреть так (приведу полный текст
команд, которые надо выполнить в `sbt console`, чтобы оно полетело (на
примере второй лабы)):

```scala
val (lhs, rhs) =
common.input.Octave.readOctaveSave("octave/lab02/sys01.cm")

val J = lab02.Jacobi(lhs, rhs, 0.01, Array.ofDim[Double](lhs.length))

J.X   			  // Выведет результат
(J.lhs, J.rhs) 		  // Выведет (левую, правую) части исходной
системы
```

также есть наборы полей, в которых содержатся вычислительные
сведения. Для справки тут, см. описание соотв метода в книге или
конспектах
